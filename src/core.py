"""
*
*    Coded by Jaspreet Singh Kalsi.
*    Implementation of "Framework for malware analysis in Android" research paper by Christian & Andres.
*    Feature Extracted : From Android_Manifest.xml.
*    Algorithm used for Classification : K-Nearest-Neighbor, Decision Tree & SVM.
*    Assessment Measurements: Accuracy &Precision
*
"""

import os

import pandas as pd
from sklearn.metrics import accuracy_score, confusion_matrix, f1_score, precision_score
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier


def load_train_dataset():
    """
    Fetching the train data & labels for both malware & normal type.
    @return: x: Train dataset.
    @return: y: Train class label.
    """
    dataset = pd.read_csv(os.path.join('dataset', 'train.csv'))
    x = dataset.iloc[:, :-1].values
    y = dataset.iloc[:, -1].values
    return x, y


def load_test_dataset():
    """
    Fetching the test data & labels for both malware & normal type.
    x, y, x_malware, y_malware, x_normal, x_normal
    @return: x: Test dataset.
    @return: y: Test class label.
    @return: x_malware: Test data only containing malware type.
    @return: y_malware: Test labels only containing malware type.
    @return: x_normal: Test data only containing normal type.
    @return: x_normal: Test labels only containing normal type.
    """
    dataset = pd.read_csv(os.path.join('dataset', 'test.csv'))
    x = dataset.iloc[:, :-1].values
    y = dataset.iloc[:, -1].values
    x_malware = []  # list for storing malware's test Data.
    y_malware = []  # list for storing Malware's Test Class Label.
    x_normal = []  # list for storing Normal's Test Data.
    y_normal = []  # list for storing Normal's Test Class Label.
    label_index = len(dataset.iloc[:].values[0]) - 1
    for data in dataset.iloc[:].values:
        if data[label_index] == 1:
            x_malware.append(data[:-1])
            y_malware.append(data[-1])
        else:
            x_normal.append(data[:-1])
            y_normal.append(data[-1])

    return x, y, x_malware, y_malware, x_normal, y_normal


def knn_model(knn_dict, x_train, y_train, x_test, x_test_malware, x_test_normal):
    """
    K-nearest-neighbor classifier predicting both malware & normal type test class label.
    @param knn_dict: Dict which contains the values of y_predicted, y_predicted_malware & y_predicted_normal.
    @param x_train: Training dataset.
    @param y_train: Labels of training dataset.
    @param x_test: Test dataset.
    @param x_test_malware: Malware's test dataset.
    @param x_test_normal: Normal's test dataset.
    @return: y_predicted: Predicted labels for test dataset.
    @return: y_predicted_malware: Predicted labels for malware's test dataset.
    @return: y_predicted_normal: Predicted labels for normal's test dataset.
    """
    model = KNeighborsClassifier(n_neighbors=4)
    model.fit(x_train, y_train)
    knn_dict['y_predicted'] = model.predict(x_test)
    knn_dict['y_predicted_malware'] = model.predict(x_test_malware)
    knn_dict['y_predicted_normal'] = model.predict(x_test_normal)


def decision_tree_model(dt_dict, x_train, y_train, x_test, x_test_malware, x_test_normal):
    """
    Decision-tree classifier predicting both malware & normal type test class label.
    @param dt_dict: Dict which contains the values of y_predicted, y_predicted_malware & y_predicted_normal.
    @param x_train: Training dataset.
    @param y_train: Labels of training dataset.
    @param x_test: Test dataset.
    @param x_test_malware: Malware's test dataset.
    @param x_test_normal: Normal's test dataset.
    @return: y_predicted: Predicted labels for test dataset.
    @return: y_predicted_malware: Predicted labels for malware's test dataset.
    @return: y_predicted_normal: Predicted labels for normal's test dataset.
    """
    model = DecisionTreeClassifier()
    model.fit(x_train, y_train)
    dt_dict['y_predicted'] = model.predict(x_test)
    dt_dict['y_predicted_malware'] = model.predict(x_test_malware)
    dt_dict['y_predicted_normal'] = model.predict(x_test_normal)


def svm_classifier(svm_dict, x_train, y_train, x_test, x_test_malware, x_test_normal):
    """
    Support vector machine classifier predicting both malware & normal type test class label.
    @param svm_dict: Dict which contains the values of y_predicted, y_predicted_malware & y_predicted_normal.
    @param x_train: Training dataset.
    @param y_train: Labels of training dataset.
    @param x_test: Test dataset.
    @param x_test_malware: Malware's test dataset.
    @param x_test_normal: Normal's test dataset.
    @return: y_predicted: Predicted labels for test dataset.
    @return: y_predicted_malware: Predicted labels for malware's test dataset.
    @return: y_predicted_normal: Predicted labels for normal's test dataset.
    """
    model = SVC(kernel='linear', C=1.0)
    model.fit(x_train, y_train)
    svm_dict['y_predicted'] = model.predict(x_test)
    svm_dict['y_predicted_malware'] = model.predict(x_test_malware)
    svm_dict['y_predicted_normal'] = model.predict(x_test_normal)


def compute_accuracy_metrics(model):
    """
    Calculate the precision_score, accuracy_score & confusion_matrix for malware & normal test dataset.
    @param dict model: Object containing dataset.
    @return:
    """
    model['ps_y_test_malware'] = precision_score(model['y_test_malware'], model['y_predicted_malware'])
    model['ps_y_test_normal'] = precision_score(model['y_test_normal'], model['y_predicted_normal'])

    model['accuracy_y_test_malware'] = accuracy_score(model['y_test_malware'], model['y_predicted_malware'])
    model['accuracy_y_test_normal'] = accuracy_score(model['y_test_normal'], model['y_predicted_normal'])

    model['cm_y_test_malware'] = confusion_matrix(model['y_test_malware'], model['y_predicted_malware']).ravel()
    model['cm_y_test_normal'] = confusion_matrix(model['y_test_normal'], model['y_predicted_normal']).ravel()

    model['f1_y_test_malware'] = f1_score(model['y_test_malware'], model['y_predicted_malware'])
    model['f1_y_test_normal'] = f1_score(model['y_test_normal'], model['y_predicted_normal'])


def main():
    knn, decision_tree, svm = {}, {}, {}
    x_train, y_train = load_train_dataset()
    x_test, y_test, x_test_malware, y_test_malware, x_test_normal, y_test_normal = load_test_dataset()
    knn_model(knn, x_train, y_train, x_test, x_test_malware, x_test_normal)
    knn['y_test'] = y_test
    knn['y_test_malware'] = y_test_malware
    knn['y_test_normal'] = y_test_normal
    compute_accuracy_metrics(knn)
    print("\n************** Results from K-nearest-neighbor classifier**************")
    print(f"Malware Accuracy: {knn['accuracy_y_test_malware']}")
    print(f"Malware f1_Score: {round(knn['f1_y_test_malware'], 2)}")

    decision_tree_model(decision_tree, x_train, y_train, x_test, x_test_malware, x_test_normal)
    decision_tree['y_test'] = y_test
    decision_tree['y_test_malware'] = y_test_malware
    decision_tree['y_test_normal'] = y_test_normal
    compute_accuracy_metrics(decision_tree)
    print("\n************** Results from Decision-Tree classifier **************")
    print(f"Malware Accuracy: {decision_tree['accuracy_y_test_malware']}")
    print(f"Malware f1_Score: {round(decision_tree['f1_y_test_malware'], 2)}")

    svm_classifier(svm, x_train, y_train, x_test, x_test_malware, x_test_normal)
    svm['y_test'] = y_test
    svm['y_test_malware'] = y_test_malware
    svm['y_test_normal'] = y_test_normal
    compute_accuracy_metrics(svm)
    print("************** Results from Support vector machine classifier **************")
    print(f"Malware Accuracy: {svm['accuracy_y_test_malware']}")
    print(f"Malware f1_Score: {round(svm['f1_y_test_malware'], 2)}")


if __name__ == '__main__':
    main()
